<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Web渗透经验总结手册 | My New Hugo Site</title>
<meta name="keywords" content="">
<meta name="description" content="">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/categories/web%E6%B8%97%E9%80%8F%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%E6%89%8B%E5%86%8C/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.36819bea596090d8b48cf10d9831382996197aa7e4fc86f792f7c08c9ca4d23b.css" integrity="sha256-NoGb6llgkNi0jPENmDE4KZYZeqfk/Ib3kvfAjJyk0js=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="http://localhost:1313/categories/web%E6%B8%97%E9%80%8F%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%E6%89%8B%E5%86%8C/index.xml">
<link rel="alternate" hreflang="en" href="http://localhost:1313/categories/web%E6%B8%97%E9%80%8F%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%E6%89%8B%E5%86%8C/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="My New Hugo Site (Alt + H)">My New Hugo Site</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>
    Web渗透经验总结手册
  </h1>
</header>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">burpsuite_intruder爆破
    </h2>
  </header>
  <div class="entry-content">
    <p>Burp Intruder主要有四个模块组成:
1：Target 用于配置目标服务器进行攻击的详细信息。 2：Positions 设置Payloads的插入点以及攻击类型（攻击模式）。 3：Payloads 设置payload，配置字典 4：Opetions 此选项卡包含了request headers，request engine，attack results ，grep match，grep_extrack，grep payloads和redirections。你可以发动攻击之前，在主要Intruder的UI上编辑这些选项，大部分设置也可以在攻击时对已在运行的窗口进行修改。
attack type:攻击模式设置 sniper:对变量依次进行破解。多个标记依次进行。 只能有一个payload 这种攻击类型是指逐个处理 Payload 列表中的每个 Payload。 每个 Payload 都会单独被插入到标记的位置，逐个测试，适用于针对单个位置进行深入测试的场景。 如果设置了三个变量A、B、C，设置了九个payload，那么先将payload插入到A变量中，当A变量测试完毕，将payload插入到B变量中，最后将payload插入到C变量进行测试. battering ram:对变量同时进行破解。多个标记同时进行。
只能有一个payload 它是Sniper的升级版，和sniper相比，battering Ram更有效率，他的原理是，同时在多个变量中进行插入测试。 pitchfork:每一个变量标记对应一个字典，取每个字典的对应项。
允许设置多个payload。 攻击类型是指同时处理两个位置，每个位置有各自的 Payload 列表。 它会按照不同的组合，将第一个 Payload 和第二个 Payload 一一配对，也就是说，他会同时去测试第一个payload和第二个payload的组合。（如果两个 Payload 列表的长度不一致，Pitchfork 模式会以数量较少的那个列表为基准，按照少的列表项数进行配对测试） 这种攻击方式可用于测试需要两个或多个位置同时受到影响的场景。 cluster bomb:每个变量对应一个字典，并且进行交集破解，尝试各种组合适用于用户名&#43;密码的破解
允许设置多个payload。 它更像是Pitchfork的加强版，它的功能与Pitchfork一样，可以同时测试多个payload，不同的是它的测试方式，是使用笛卡尔积，例如设置两个变量A、B，和两个payload位置，payload会交叉测试，也就是说payload1首先会是在变量A的位置，去测变量B中的payload2中所有的参数 ，当变量B中的payload2所有参数都测试完，变量A、B的payload会互相交换位置，进行测试，用最通俗的话来讲，他们就是乘法关系，假如连个payload中的参数是4个，那么他就会测试4*4=16次。 Cluster Bomb 通过组合 Payload 列表，生成了更多的组合，这样可以更全面、更彻底地测试目标应用程序，寻找潜在的漏洞。 payload type Simple list（简单列表）: 基本的常规 Payload 列表，可能包含用户名、密码或常见字符串。 Runtime file（运行时文件）: 在运行时生成或读取文件作为 Payload，用于测试文件上传或处理漏洞。 Custom iterator（自定义迭代器）: 使用自定义算法或迭代方法生成 Payload。 Character substitution（字符替换）: 对字符进行替换或修改来生成不同形式的 Payload。 Case modification（大小写修改）: 改变字符的大小写来生成不同形式的 Payload。 Recursive grep（递归查找）: 使用递归方式搜索目标系统，生成特定形式的 Payload。 Illegal Unicode（非法 Unicode）: 使用不合法或特殊的 Unicode 字符串生成 Payload。 Character blocks（字符块）: 将字符分组或分块，以块为单位生成 Payload。 Numbers（数字）: 针对数字型输入生成不同种类的数字 Payload。 Dates（日期）: 针对日期型输入生成不同形式的日期 Payload。 Brute forcer（暴力破解器）: 用于尝试各种可能性的暴力破解 Payload。 Null payloads（空 Payload）: 使用空值或空字符串作为 Payload。 Character frobber（字符操作）: 对字符进行多种操作生成 Payload。 Bit flipper（位操作）: 对比特位进行操作生成 Payload。 Username generator（用户名生成器）: 生成各种类型的用户名 Payload。 ECB block shuffler（ECB 块置换器）: 针对 ECB 模式加密的情况生成 Payload。 Extension-generated（扩展生成）: 由扩展或自定义脚本生成的特定 Payload。 Copy other payload（复制其他 Payload）: 复制已有 Payload 作为新的 Payload。 Collaborator payloads（协作者 Payload）: 使用 Burp Collaborator 进行协作的特定 Payload。
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-03-10 00:00:00 +0000 UTC'>March 10, 2025</span>&nbsp;·&nbsp;AuranLu</footer>
  <a class="entry-link" aria-label="post link to burpsuite_intruder爆破" href="http://localhost:1313/posts/auran_lu/web%E6%B8%97%E9%80%8F%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%E6%89%8B%E5%86%8C/burpsuite_intruder%E7%88%86%E7%A0%B4/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">dirsearch使用手册
    </h2>
  </header>
  <div class="entry-content">
    <p>扫描的目标-u,--url 目标url-l,--url-list=FILE 目标url文件路径 --stdin 从标准输入中指定url--cidr 目标网段--raw=File 从文件中读取request报文,通过-schema指定策略(如--schema https) 扫描的字典类型-e,--extensions 包含的文件拓展名(逗号分隔) 如-e php,asp -X,--exclude-extensions 排除的文件拓展名(逗号分隔) 如-X asp,jsp-f,--force-extensions 在字典的每条记录后面添加文件拓展名dirsearch默认只会替换字典中%EXT%为指定的extensions 如-e php Wishlist.%EXT%--&gt;Wishlist.php 字典格式设置-w,--wordlists 自定义wordlist(以逗号分隔)--prefixes 添加自定义前缀--suffixes	添加自定义后缀--only-selected 筛选出指定的文件拓展名或无文件拓展名的目录--remove-extensions 移除所有wordlist的后缀名 (admin.php --&gt; admin)-U, --uppercase 将字典转换为大写-L, --lowercase	将字典转换为小写-C, --capital 第一个字母大写剩下字母小写 响应结果的过滤-i 保留的响应状态码(以逗号分隔,支持指定范围) 如(-i 200,300-399)-x 排除的响应状态码(以逗号分隔,支持指定范围) 如(-x 301,500-599)--exclude-sizes 通过大小排除(以逗号分隔) 如(123B,4KB)--exclude-texts 通过文本内容排除响应(&#39;Not found&#39;, &#39;Error&#39;)--exclude-regexps 通过正则匹配排除响应(&#39;Not foun[a-z]{1}&#39;, &#39;^Error$&#39;)--exclude-redirects 通过正则跳转目标排除响应(&#39;https://okta.com/*&#39;)--minimal 最小响应报文长度--maximal 最大响应报文长度 请求相关设置-m,--http-method HTTP请求方法 默认为GET-d,--data HTTP请求数据-H,--header 请求头 如(-H &#39;Referer: example.com&#39; -H &#39;Accept: */*&#39;)--header-list=FILE 从文件中读取请求头-F,--follow-redirects 跟随HTTP跳转--user-agent 设置user-agent字段--cookie 设置cookie 连接相关设置--timeout=TIMEOUT 连接超时时间--ip=IP 服务器ip地址-s DELAY, --delay=DELAY 每次请求间隔的时间--proxy=PROXY 代理url 支持HTTP和SOCKS代理 如(localhost:8080, socks5://localhost:8088)--proxy-list=FILE 包含代理服务器的地址--matches-proxy=PROXY Proxy to replay with found paths--scheme 默认的策略 用于从文件中导入请求或url中不包含协议--max-retries 最大重连次数-b,--request-by-hostname 强制通过域名连接，(默认为了速度,使用ip连接)--exit-on-error 出现错误时退出--debug	Debug模式 通用设置--version 显示dirsearch的版本-h --help 帮助提示-r,--recursive 递归爆破-R,--recursion-depth 最大递归的层数-t,--threads 线程数--subdirs 扫描子目录 如(admin/ 则www.example.com/admin/&#43;字典)--exclude-subdirs 在递归扫描中排除的子目录-q,--quiet-mode 安静模式--full-url 打印出完整的url--no-color 无颜色输出信息 输出模式--simple-report=OUTPUTFILE--plain-text-report=OUTPUTFILE--json-report=OUTPUTFILE--xml-report=OUTPUTFILE--markdown-report=OUTPUTFILE--csv-report=OUTPUTFILE 可以通过修改default.conf文件去修改dirsearch的默认配置(默认文件拓展名，超时时间，wordlist所在目录等)
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-03-10 00:00:00 +0000 UTC'>March 10, 2025</span>&nbsp;·&nbsp;AuranLu</footer>
  <a class="entry-link" aria-label="post link to dirsearch使用手册" href="http://localhost:1313/posts/auran_lu/web%E6%B8%97%E9%80%8F%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%E6%89%8B%E5%86%8C/dirsearch%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">dns检验查询
    </h2>
  </header>
  <div class="entry-content">
    <p>
</p>
  </div>
  <footer class="entry-footer"><span title='2025-03-10 00:00:00 +0000 UTC'>March 10, 2025</span>&nbsp;·&nbsp;AuranLu</footer>
  <a class="entry-link" aria-label="post link to dns检验查询" href="http://localhost:1313/posts/auran_lu/web%E6%B8%97%E9%80%8F%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%E6%89%8B%E5%86%8C/dns%E6%A3%80%E9%AA%8C%E6%9F%A5%E8%AF%A2/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">docker基本命令
    </h2>
  </header>
  <div class="entry-content">
    <p>一、docker基本命令 （1）查找镜像：docker search 镜像名称（如：tomcat）
（2）拉取镜像：docker pull 镜像名称（如：tomcat）
（3）保存指定镜像为指定文件：docker save -o c:\dockerimage\awvs.img（指定文件） 0xgkd/awvs:latest（指定镜像名称或id）
（4）从指定文件加载为镜像：docker load -i c:\dockerimage\awvs.img（指定文件）
创建一个名为 my_nginx 的容器 docker create --name my_nginx nginx 命令开启创建的容器 docker start my_nginx docker run命令用于创建并启动一个新的容器。 docker run ubuntu /bin/bash docker start 命令用于启动一个已经存在的容器 docker start my_container 使用 docker stop 命令停止容器 docker stop my_nginx 使用 docker rm 命令删除容器 docker rm my_nginx 其他常用命令 容器日志查看：使用 docker logs 命令查看容器日志，例如 docker logs my_nginx。 容器内部执行命令：使用 docker exec 命令在运行中的容器内执行命令，例如 docker exec -it my_nginx bash。其中参数-it表示交互式模式，即 -i（交互式）和 -t（终端）。 容器列表查看：使用 docker ps 命令查看运行中的容器列表，加上-a 参数可以查看所有容器列表，包括停止的容器。 当使用 docker run 命令时，除了常见参数 -d（后台运行）和 -p（端口映射）之外，还有一些其他常用参数： -v：挂载主机目录到容器内部，用于数据持久化。 -e：设置容器内的环境变量。 –name：为容器指定一个自定义的名称。 -i：启动一个交互式容器。 -t：为容器分配一个伪终端。 –restart：指定容器退出时的重启策略。 –network：指定容器所属的网络模式。 –link：链接另一个容器。 </p>
  </div>
  <footer class="entry-footer"><span title='2025-03-10 00:00:00 +0000 UTC'>March 10, 2025</span>&nbsp;·&nbsp;AuranLu</footer>
  <a class="entry-link" aria-label="post link to docker基本命令" href="http://localhost:1313/posts/auran_lu/web%E6%B8%97%E9%80%8F%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%E6%89%8B%E5%86%8C/docker/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Git命令手册
    </h2>
  </header>
  <div class="entry-content">
    <p>常用语句 git init # 初始化本地git仓库（创建新仓库） git config --global user.name &#34;xxx&#34; # 配置用户名 git config --global user.email &#34;xxx@xxx.com&#34; # 配置邮件 git config --global color.ui true # git status等命令自动着色 git config --global color.status auto git config --global color.diff auto git config --global color.branch auto git config --global color.interactive auto git config --global --unset http.proxy # remove proxy configuration on git git clone git&#43;ssh://git@192.168.53.168/VT.git # clone远程仓库 git status # 查看当前版本状态（是否修改） git add xyz # 添加xyz文件至index git add . # 增加当前子目录下所有更改过的文件至index git commit -m &#39;xxx&#39; # 提交 git commit --amend -m &#39;xxx&#39; # 合并上一次提交（用于反复修改） git commit -am &#39;xxx&#39; # 将add和commit合为一步 git rm xxx # 删除index中的文件 git rm -r * # 递归删除 git log # 显示提交日志 git log -1 # 显示1行日志 -n为n行 git log -5 git log --stat # 显示提交日志及相关变动文件 git log -p -m git show dfb02e6e4f2f7b573337763e5c0013802e392818 # 显示某个提交的详细内容 git show dfb02 # 可只用commitid的前几位 git show HEAD # 显示HEAD提交日志 git show HEAD^ # 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本 git tag # 显示已存在的tag git tag -a v2.0 -m &#39;xxx&#39; # 增加v2.0的tag git show v2.0 # 显示v2.0的日志及详细内容 git log v2.0 # 显示v2.0的日志 git diff # 显示所有未添加至index的变更 git diff --cached # 显示所有已添加index但还未commit的变更 git diff HEAD^ # 比较与上一个版本的差异 git diff HEAD -- ./lib # 比较与HEAD版本lib目录的差异 git diff origin/master..master # 比较远程分支master上有本地分支master上没有的 git diff origin/master..master --stat # 只显示差异的文件，不显示具体内容 git remote add origin git&#43;ssh://git@192.168.53.168/VT.git # 增加远程定义（用于push/pull/fetch） git branch # 显示本地分支 git branch --contains 50089 # 显示包含提交50089的分支 git branch -a # 显示所有分支 git branch -r # 显示所有原创分支 git branch --merged # 显示所有已合并到当前分支的分支 git branch --no-merged # 显示所有未合并到当前分支的分支 git branch -m master master_copy # 本地分支改名 git checkout -b master_copy # 从当前分支创建新分支master_copy并检出 git checkout -b master master_copy # 上面的完整版 git checkout features/performance # 检出已存在的features/performance分支 git checkout --track hotfixes/BJVEP933 # 检出远程分支hotfixes/BJVEP933并创建本地跟踪分支 git checkout v2.0 # 检出版本v2.0 git checkout -b devel origin/develop # 从远程分支develop创建新本地分支devel并检出 git checkout -- README # 检出head版本的README文件（可用于修改错误回退） git merge origin/master # 合并远程master分支至当前分支 git cherry-pick ff44785404a8e # 合并提交ff44785404a8e的修改 git push origin master # 将当前分支push到远程master分支 git push origin :hotfixes/BJVEP933 # 删除远程仓库的hotfixes/BJVEP933分支 git push --tags # 把所有tag推送到远程仓库 git fetch # 获取所有远程分支（不更新本地分支，另需merge） git fetch --prune # 获取所有原创分支并清除服务器上已删掉的分支 git pull origin master # 获取远程分支master并merge到当前分支 git mv README README2 # 重命名文件README为README2 git reset --hard HEAD # 将当前版本重置为HEAD（通常用于merge失败回退） git rebase git branch -d hotfixes/BJVEP933 # 删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支） git branch -D hotfixes/BJVEP933 # 强制删除分支hotfixes/BJVEP933 git ls-files # 列出git index包含的文件 git show-branch # 图示当前分支历史 git show-branch --all # 图示所有分支历史 git whatchanged # 显示提交历史对应的文件修改 git revert dfb02e6e4f2f7b573337763e5c0013802e392818 # 撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818 git ls-tree HEAD # 内部命令：显示某个git对象 git rev-parse v2.0 # 内部命令：显示某个ref对于的SHA1 HASH git reflog # 显示所有提交，包括孤立节点 git show HEAD@{5} git show master@{yesterday} # 显示master分支昨天的状态 git log --pretty=format:&#39;%h %s&#39; --graph # 图示提交日志 git show HEAD~3 git show -s --pretty=raw 2be7fcb476 git stash # 暂存当前修改，将所有至为HEAD状态 git stash list # 查看所有暂存 git stash show -p stash@{0} # 参考第一次暂存 git stash apply stash@{0} # 应用第一次暂存 git grep &#34;delete from&#34; # 文件中搜索文本“delete from” git grep -e &#39;#define&#39; --and -e SORT_DIRENT git gc git fsck 新建：创建一个新的 git 版本库。这个版本库的配置、存储等信息会被保存到git 文件夹中 # 初始化当前项目 $ git init # 新建一个目录，将其初始化为Git代码库 $ git init [project-name] # 在指定目录创建一个空的 Git 仓库。运行这个命令会创建一个名为 directory，只包含 .git 子目录的空目录。 $ git init --bare &lt;directory&gt; # 下载一个项目和它的整个代码历史 # 这个命令就是将一个版本库拷贝到另一个目录中，同时也将分支都拷贝到新的版本库中。这样就可以在新的版本库中提交到远程分支 $ git clone [url] 配置：更改设置。可以是版本库的设置，也可以是系统的或全局的 # 显示当前的Git配置 $ git config --list # 编辑Git配置文件 $ git config -e [--global] # 输出、设置基本的全局变量 $ git config --global user.email $ git config --global user.name $ git config --global user.email &#34;MyEmail@gmail.com&#34; $ git config --global user.name &#34;My Name&#34; # 定义当前用户所有提交使用的作者邮箱。 $ git config --global alias.&lt;alias-name&gt; &lt;git-command&gt; # 为Git命令创建一个快捷方式（别名）。 $ git config --system core.editor &lt;editor&gt; 状态：显示索引文件（也就是当前工作空间）和当前的头指针指向的提交的不同 # 显示分支，未跟踪文件，更改和其他不同 $ git status # 查看其他的git status的用法 $ git help status 信息：获取某些文件，某些分支，某次提交等 git 信息 # 显示commit历史，以及每次commit发生变更的文件 $ git log --stat # 搜索提交历史，根据关键词 $ git log -S [keyword] # 显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD --pretty=format:%s # 显示某个commit之后的所有变动，其&#34;提交说明&#34;必须符合搜索条件 $ git log [tag] HEAD --grep feature # 显示某个文件的版本历史，包括文件改名 $ git log --follow [file] $ git whatchanged [file] # 显示指定文件相关的每一次diff $ git log -p [file] # 显示过去5次提交 $ git log -5 --pretty --oneline # 显示所有提交过的用户，按提交次数排序 $ git shortlog -sn # 显示指定文件是什么人在什么时间修改过 $ git blame [file] # 显示暂存区和工作区的差异 $ git diff # 显示暂存区和上一个commit的差异 $ git diff --cached [file] # 显示工作区与当前分支最新commit之间的差异 $ git diff HEAD # 显示两次提交之间的差异 $ git diff [first-branch]...[second-branch] # 显示今天你写了多少行代码 $ git diff --shortstat &#34;@{0 day ago}&#34; # 比较暂存区和版本库差异 $ git diff --staged # 比较暂存区和版本库差异 $ git diff --cached # 仅仅比较统计信息 $ git diff --stat # 显示某次提交的元数据和内容变化 $ git show [commit] # 显示某次提交发生变化的文件 $ git show --name-only [commit] # 显示某次提交时，某个文件的内容 $ git show [commit]:[filename] # 显示当前分支的最近几次提交 $ git reflog # 查看远程分支 $ git br -r # 创建新的分支 $ git br &lt;new_branch&gt; # 查看各个分支最后提交信息 $ git br -v # 查看已经被合并到当前分支的分支 $ git br --merged # 查看尚未被合并到当前分支的分支 $ git br --no-merged 添加：添加文件到当前工作空间中。如果你不使用 git add 将文件添加进去，那么这些文件也不会添加到之后的提交之中 # 添加一个文件 $ git add test.js # 添加一个子目录中的文件 $ git add /path/to/file/test.js # 支持正则表达式 $ git add ./*.js # 添加指定文件到暂存区 $ git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录 $ git add [dir] # 添加当前目录的所有文件到暂存区 $ git add . # 添加每个变化前，都会要求确认 # 对于同一个文件的多处变化，可以实现分次提交 $ git add -p 删除：rm 和上面的 add 命令相反，从工作空间中去掉某个文件 # 移除 HelloWorld.js $ git rm HelloWorld.js # 移除子目录中的文件 $ git rm /pather/to/the/file/HelloWorld.js # 删除工作区文件，并且将这次删除放入暂存区 $ git rm [file1] [file2] ... # 停止追踪指定文件，但该文件会保留在工作区 $ git rm --cached [file] 分支：管理分支，可以通过下列命令对分支进行增删改查切换等 # 查看所有的分支和远程分支 $ git branch -a # 创建一个新的分支 $ git branch [branch-name] # 重命名分支 # git branch -m &lt;旧名称&gt; &lt;新名称&gt; $ git branch -m [branch-name] [new-branch-name] # 编辑分支的介绍 $ git branch [branch-name] --edit-description # 列出所有本地分支 $ git branch # 列出所有远程分支 $ git branch -r # 新建一个分支，但依然停留在当前分支 $ git branch [branch-name] # 新建一个分支，并切换到该分支 $ git checkout -b [branch] # 新建一个分支，指向指定commit $ git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系 $ git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区 $ git checkout [branch-name] # 切换到上一个分支 $ git checkout - # 建立追踪关系，在现有分支与指定的远程分支之间 $ git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支 $ git merge [branch] # 选择一个commit，合并进当前分支 $ git cherry-pick [commit] # 删除分支 $ git branch -d [branch-name] # 删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch] # 切换到某个分支 $ git co &lt;branch&gt; # 创建新的分支，并且切换过去 $ git co -b &lt;new_branch&gt; # 基于branch创建新的new_branch $ git co -b &lt;new_branch&gt; &lt;branch&gt; # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除 $ git co $id # 把某次历史提交记录checkout出来，创建成一个分支 $ git co $id -b &lt;new_branch&gt; # 删除某个分支 $ git br -d &lt;branch&gt; # 强制删除某个分支 (未被合并的分支被删除的时候需要强制) $ git br -D &lt;branch&gt; 检出：将当前工作空间更新到索引所标识的或者某一特定的工作空间 # 检出一个版本库，默认将更新到master分支 $ git checkout # 检出到一个特定的分支 $ git checkout branchName # 新建一个分支，并且切换过去，相当于&#34;git branch &lt;名字&gt;; git checkout &lt;名字&gt;&#34; $ git checkout -b newBranch 远程同步：远程同步的远端分支 # 下载远程仓库的所有变动 $ git fetch [remote] # 显示所有远程仓库 $ git remote -v # 显示某个远程仓库的信息 $ git remote show [remote] # 增加一个新的远程仓库，并命名 $ git remote add [shortname] [url] # 查看远程服务器地址和仓库名称 $ git remote -v # 添加远程仓库地址 $ git remote add origin git@ github:xxx/xxx.git # 设置远程仓库地址(用于修改远程仓库地址) $ git remote set-url origin git@ github.com:xxx/xxx.git # 删除远程仓库 $ git remote rm &lt;repository&gt; # 上传本地指定分支到远程仓库 # 把本地的分支更新到远端origin的master分支上 # git push &lt;远端&gt; &lt;分支&gt; # git push 相当于 git push origin master $ git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --force # 推送所有分支到远程仓库 $ git push [remote] --all 撤销： # 恢复暂存区的指定文件到工作区 $ git checkout [file] # 恢复某个commit的指定文件到暂存区和工作区 $ git checkout [commit] [file] # 恢复暂存区的所有文件到工作区 $ git checkout . # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 $ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致 $ git reset --hard # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 $ git reset [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset --hard [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git reset --keep [commit] # 新建一个commit，用来撤销指定commit # 后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit] # 恢复最后一次提交的状态 $ git revert HEAD # 暂时将未提交的变化移除，稍后再移入 $ git stash $ git stash pop # 列所有stash $ git stash list # 恢复暂存的内容 $ git stash apply # 删除暂存区 $ git stash drop 提交：commit 将当前索引的更改保存为一个新的提交，这个提交包括用户做出的更改与信息 # 提交暂存区到仓库区附带提交信息 $ git commit -m [message] # 提交暂存区的指定文件到仓库区 $ git commit [file1] [file2] ... -m [message] # 提交工作区自上次commit之后的变化，直接到仓库区 $ git commit -a # 提交时显示所有diff信息 $ git commit -v # 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit --amend -m [message] # 重做上一次commit，并包括指定文件的新变化 $ git commit --amend [file1] [file2] ... diff: 显示当前工作空间和提交的不同 # 显示工作目录和索引的不同 $ git diff # 显示索引和最近一次提交的不同 $ git diff --cached # 显示工作目录和最近一次提交的不同 $ git diff HEAD grep：可以在版本库中快速查找 可选配置： # 感谢Travis Jeffery提供的以下用法： # 在搜索结果中显示行号 $ git config --global grep.lineNumber true # 是搜索结果可读性更好 $ git config --global alias.g &#34;grep --break --heading --line-number&#34; # 在所有的java中查找variableName $ git grep &#39;variableName&#39; -- &#39;*.java&#39; # 搜索包含 &#34;arrayListName&#34; 和, &#34;add&#34; 或 &#34;remove&#34; 的所有行 $ git grep -e &#39;arrayListName&#39; --and \( -e add -e remove \) log: 显示这个版本库的所有提交 # 显示所有提交 $ git log # 显示某几条提交信息 $ git log -n 10 # 仅显示合并提交 $ git log --merges # 查看该文件每次提交记录 $ git log &lt;file&gt; # 查看每次详细修改内容的diff $ git log -p &lt;file&gt; # 查看最近两次详细修改内容的diff $ git log -p -2 #查看提交统计信息 $ git log --stat merge: 合并就是将外部的提交合并到自己的分支中 # 将其他分支合并到当前分支 $ git merge branchName # 在合并时创建一个新的合并后的提交 # 不要 Fast-Foward 合并，这样可以生成 merge 提交 $ git merge --no-ff branchName mv：重命名或移动一个文件 # 重命名 $ git mv test.js test2.js # 移动 $ git mv test.js ./new/path/test.js # 改名文件，并且将这个改名放入暂存区 $ git mv [file-original] [file-renamed] # 强制重命名或移动 # 这个文件已经存在，将要覆盖掉 $ git mv -f myFile existingFile tag: # 列出所有tag $ git tag # 新建一个tag在当前commit $ git tag [tag] # 新建一个tag在指定commit $ git tag [tag] [commit] # 删除本地tag $ git tag -d [tag] # 删除远程tag $ git push origin :refs/tags/[tagName] # 查看tag信息 $ git show [tag] # 提交指定tag $ git push [remote] [tag] # 提交所有tag $ git push [remote] --tags # 新建一个分支，指向某个tag $ git checkout -b [branch] [tag] push：从远端版本库合并到当前分支 # 从远端origin的master分支更新版本库 # git pull &lt;远端&gt; &lt;分支&gt; $ git pull origin master # 抓取远程仓库所有分支更新并合并到本地，不要快进合并 $ git pull --no-ff ci： $ git ci &lt;file&gt; $ git ci . # 将git add, git rm和git ci等操作都合并在一起做 $ git ci -a $ git ci -am &#34;some comments&#34; # 修改最后一次提交记录 $ git ci --amend rebase（谨慎使用）：将一个分支上所有的提交历史都应用到另一个分支上不要在一个已经公开的远端分支上使用 rebase. # 将experimentBranch应用到master上面 # git rebase &lt;basebranch&gt; &lt;topicbranch&gt; $ git rebase master experimentBranch reset (谨慎使用) 将当前的头指针复位到一个特定的状态。这样可以使你撤销 merge、pull、commits、add 等 这是个很强大的命令，但是在使用时一定要清楚其所产生的后果 # 使 staging 区域恢复到上次提交时的状态，不改变现在的工作目录 $ git reset # 使 staging 区域恢复到上次提交时的状态，覆盖现在的工作目录 $ git reset --hard # 将当前分支恢复到某次提交，不改变现在的工作目录 # 在工作目录中所有的改变仍然存在 $ git reset dha78as # 将当前分支恢复到某次提交，覆盖现在的工作目录 # 并且删除所有未提交的改变和指定提交之后的所有提交 $ git reset --hard dha78as 其他： # 生成一个可供发布的压缩包 $ git archive # 打补丁 $ git apply ../sync.patch # 测试补丁能否成功 $ git apply --check ../sync.patch # 查看Git的版本 $ git --version </p>
  </div>
  <footer class="entry-footer"><span title='2025-03-10 00:00:00 +0000 UTC'>March 10, 2025</span>&nbsp;·&nbsp;AuranLu</footer>
  <a class="entry-link" aria-label="post link to Git命令手册" href="http://localhost:1313/posts/auran_lu/web%E6%B8%97%E9%80%8F%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%E6%89%8B%E5%86%8C/git%E5%91%BD%E4%BB%A4%E6%89%8B%E5%86%8C/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">JS拦截绕过方法
    </h2>
  </header>
  <div class="entry-content">
    <p> 关闭浏览器的JavaScript 使用BurpSuite抓包查看回显 在访问时前缀view-source：用于查看网页源码 </p>
  </div>
  <footer class="entry-footer"><span title='2025-03-10 00:00:00 +0000 UTC'>March 10, 2025</span>&nbsp;·&nbsp;AuranLu</footer>
  <a class="entry-link" aria-label="post link to JS拦截绕过方法" href="http://localhost:1313/posts/auran_lu/web%E6%B8%97%E9%80%8F%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%E6%89%8B%E5%86%8C/js%E6%8B%A6%E6%88%AA%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">oneforall使用手册
    </h2>
  </header>
  <div class="entry-content">
    <p>python oneforall.py –target baidu.com run
NAMEoneforall.py - OneForAll帮助信息SYNOPSISoneforall.py COMMAND | --target=TARGET &lt;flags&gt;DESCRIPTIONOneForAll是一款功能强大的子域收集工具Example:python3 oneforall.py versionpython3 oneforall.py --target example.com runpython3 oneforall.py --target ./domains.txt runpython3 oneforall.py --target example.com --valid None runpython3 oneforall.py --target example.com --brute True runpython3 oneforall.py --target example.com --port small runpython3 oneforall.py --target example.com --format csv runpython3 oneforall.py --target example.com --dns False runpython3 oneforall.py --target example.com --req False runpython3 oneforall.py --target example.com --takeover False runpython3 oneforall.py --target example.com --show True runNote:参数alive可选值True，False分别表示导出存活，全部子域结果参数port可选值有&#39;default&#39;, &#39;small&#39;, &#39;large&#39;, 详见config.py配置参数format可选格式有&#39;rst&#39;, &#39;csv&#39;, &#39;tsv&#39;, &#39;json&#39;, &#39;yaml&#39;, &#39;html&#39;,&#39;jira&#39;, &#39;xls&#39;, &#39;xlsx&#39;, &#39;dbf&#39;, &#39;latex&#39;, &#39;ods&#39;参数path默认None使用OneForAll结果目录生成路径ARGUMENTSTARGET单个域名或者每行一个域名的文件路径(必需参数)FLAGS--brute=BRUTE使用爆破模块(默认False)--dns=DNSDNS解析子域(默认True)--req=REQHTTP请求子域(默认True)--port=PORT请求验证子域的端口范围(默认只探测80端口)--valid=VALID只导出存活的子域结果(默认False)--format=FORMAT结果保存格式(默认csv)--path=PATH结果保存路径(默认None)--takeover=TAKEOVER检查子域接管(默认False) </p>
  </div>
  <footer class="entry-footer"><span title='2025-03-10 00:00:00 +0000 UTC'>March 10, 2025</span>&nbsp;·&nbsp;AuranLu</footer>
  <a class="entry-link" aria-label="post link to oneforall使用手册" href="http://localhost:1313/posts/auran_lu/web%E6%B8%97%E9%80%8F%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%E6%89%8B%E5%86%8C/oneforall%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">PHP_伪协议
    </h2>
  </header>
  <div class="entry-content">
    <p>PHP伪协议详解 php支持的伪协议
1 file:// — 访问本地文件系统2 http:// — 访问 HTTP(s) 网址3 ftp:// — 访问 FTP(s) URLs4 php:// — 访问各个输入/输出流（I/O streams）5 zlib:// — 压缩流6 data:// — 数据（RFC 2397）7 glob:// — 查找匹配的文件路径模式8 phar:// — PHP 归档9 ssh2:// — Secure Shell 210 rar:// — RAR11 ogg:// — 音频流12 expect:// — 处理交互式的流 1. file:// 示例：
1.file://[文件的绝对路径和文件名]
http://127.0.0.1/include.php?file=file://E:\phpStudy\PHPTutorial\WWW\phpinfo.txt 2.file://[文件的相对路径和文件名]
http://127.0.0.1/include.php?file=./phpinfo.txt 3.http://网络位置和文件名
http://127.0.0.1/include.php?file=http://127.0.0.1/phpinfo.txt 2. php://filter php://filter 是一种元封装器， 设计用于数据流打开时的筛选过滤应用。 这对于一体式（all-in-one）的文件函数非常有用，类似 readfile()、 file() 和 file_get_contents()， 在数据流内容读取之前没有机会应用其他过滤器。
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-03-10 00:00:00 +0000 UTC'>March 10, 2025</span>&nbsp;·&nbsp;AuranLu</footer>
  <a class="entry-link" aria-label="post link to PHP_伪协议" href="http://localhost:1313/posts/auran_lu/web%E6%B8%97%E9%80%8F%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%E6%89%8B%E5%86%8C/php_%E4%BC%AA%E5%8D%8F%E8%AE%AE/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">phps文件源码泄露
    </h2>
  </header>
  <div class="entry-content">
    <p>原理 phps文件就是php的源代码文件，通常用于提供给用户（访问者）查看php代码，因为用户无法直接通过Web浏览器看到php文件的内容，所以需要用phps文件代替。其实，只要不用php等已经在服务器中注册过的MIME类型为文件即可，但为了国际通用，所以才用了phps文件类型。
如果您使用.php作为文件的扩展名，则服务器将解释该脚本背后的代码并返回所需的输出。而.phps将直接输出该脚本的颜色格式化内容，如下所示。
工具 御剑（扫后台）
利用 通常访问php同名phps文件即可获得源码
</p>
  </div>
  <footer class="entry-footer"><span title='2025-03-10 00:00:00 +0000 UTC'>March 10, 2025</span>&nbsp;·&nbsp;AuranLu</footer>
  <a class="entry-link" aria-label="post link to phps文件源码泄露" href="http://localhost:1313/posts/auran_lu/web%E6%B8%97%E9%80%8F%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%E6%89%8B%E5%86%8C/phps%E6%96%87%E4%BB%B6%E6%BA%90%E7%A0%81%E6%B3%84%E9%9C%B2/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">PHP常见方法和函数
    </h2>
  </header>
  <div class="entry-content">
    <p> md5() 函数是一个哈希函数，它将传入的参数进行哈希处理并返回一个32位的十六进制字符串
hexdec() 函数将十六进制字符串转换为对应的十进制数值。
mt_rand()函数
mt_rand() 函数使用 Mersenne Twister 算法生成随机整数。使用语法：mt_rand(); or mt_rand(min,max);，生成一个区间内的随机数。其参数min默认为最小值0，max默认为可生成的随机数最大值2147483647，由mt_getrandmax()函数获得。 mt_srand()函数
mt_srand() 函数播种 Mersenne Twister 随机数生成器。提示：从 PHP 4.2.0 开始，随机数生成器自动播种，因此没有必要使用该函数。当不使用随机数播种函数srand时，php也会自动为随机数播种，因此是否确定种子都不会影响正常运行。 在php中每一次调用mt_rand()函数，都会检查一下系统有没有播种。（播种为mt_srand()函数完成），当随机种子生成后，后面生成的随机数都会根据这个随机种子生成。所以同一个种子下，随机数的序列是相同的，这就是漏洞点，两个例子。
&lt;?PHP mt_srand(0);echo mt_rand();echo mt_rand();echo mt_rand();?&gt; 在上面的代码中，我们把随机数播种为0，每次运行都会获得相同的序列，这就是伪随机：
96393219212731241191535857466 当我们去掉mt_srand()函数时，再次重复运行实例，系统会自动为rand函数播种，但也是播种一次。因此多次重复运行的结果也相同，为：
9929788299287481011380702626 由于 Mt19937（“梅森旋转算法”）引擎仅接受 32 位整数作为种子，因此尽管 Mt19937 的范围为 219937-1，但可能的随机序列数量仅限于 232（即 4,294,967,296）。
当依赖隐式或显式随机播种时，重复会出现得更早。根据生日问题，在少于 80,000 个随机生成的种子后，预计重复种子的概率为 50%。在随机生成大约 30,000 个种子后，重复种子的概率为 10%。
intval() 函数用于获取变量的整数值。
int preg_match ( string $pattern , string $subject [, array &amp;$matches [, int $flags = 0 [, int $offset = 0 ]]] ) 搜索 subject 与 pattern 给定的正则表达式的一个匹配。
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-03-10 00:00:00 +0000 UTC'>March 10, 2025</span>&nbsp;·&nbsp;AuranLu</footer>
  <a class="entry-link" aria-label="post link to PHP常见方法和函数" href="http://localhost:1313/posts/auran_lu/web%E6%B8%97%E9%80%8F%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%E6%89%8B%E5%86%8C/php%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95%E5%92%8C%E5%87%BD%E6%95%B0/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="next" href="http://localhost:1313/categories/web%E6%B8%97%E9%80%8F%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%E6%89%8B%E5%86%8C/page/2/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">My New Hugo Site</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
