<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>burpsuite_intruder爆破 | My New Hugo Site</title>
<meta name="keywords" content="burpsuite_intruder爆破">
<meta name="description" content="Burp Intruder主要有四个模块组成:
1：Target 用于配置目标服务器进行攻击的详细信息。
2：Positions  设置Payloads的插入点以及攻击类型（攻击模式）。
3：Payloads  设置payload，配置字典
4：Opetions   此选项卡包含了request headers，request engine，attack results ，grep match，grep_extrack，grep payloads和redirections。你可以发动攻击之前，在主要Intruder的UI上编辑这些选项，大部分设置也可以在攻击时对已在运行的窗口进行修改。

attack type:攻击模式设置


sniper:对变量依次进行破解。多个标记依次进行。

只能有一个payload
这种攻击类型是指逐个处理 Payload 列表中的每个 Payload。
每个 Payload 都会单独被插入到标记的位置，逐个测试，适用于针对单个位置进行深入测试的场景。
如果设置了三个变量A、B、C，设置了九个payload，那么先将payload插入到A变量中，当A变量测试完毕，将payload插入到B变量中，最后将payload插入到C变量进行测试.






battering ram:对变量同时进行破解。多个标记同时进行。

只能有一个payload
它是Sniper的升级版，和sniper相比，battering Ram更有效率，他的原理是，同时在多个变量中进行插入测试。




pitchfork:每一个变量标记对应一个字典，取每个字典的对应项。

允许设置多个payload。
攻击类型是指同时处理两个位置，每个位置有各自的 Payload 列表。
它会按照不同的组合，将第一个 Payload 和第二个 Payload 一一配对，也就是说，他会同时去测试第一个payload和第二个payload的组合。（如果两个 Payload 列表的长度不一致，Pitchfork 模式会以数量较少的那个列表为基准，按照少的列表项数进行配对测试）
这种攻击方式可用于测试需要两个或多个位置同时受到影响的场景。



cluster bomb:每个变量对应一个字典，并且进行交集破解，尝试各种组合适用于用户名&#43;密码的破解

允许设置多个payload。
它更像是Pitchfork的加强版，它的功能与Pitchfork一样，可以同时测试多个payload，不同的是它的测试方式，是使用笛卡尔积，例如设置两个变量A、B，和两个payload位置，payload会交叉测试，也就是说payload1首先会是在变量A的位置，去测变量B中的payload2中所有的参数 ，当变量B中的payload2所有参数都测试完，变量A、B的payload会互相交换位置，进行测试，用最通俗的话来讲，他们就是乘法关系，假如连个payload中的参数是4个，那么他就会测试4*4=16次。
Cluster Bomb 通过组合 Payload 列表，生成了更多的组合，这样可以更全面、更彻底地测试目标应用程序，寻找潜在的漏洞。




payload type
Simple list（简单列表）: 基本的常规 Payload 列表，可能包含用户名、密码或常见字符串。
Runtime file（运行时文件）: 在运行时生成或读取文件作为 Payload，用于测试文件上传或处理漏洞。
Custom iterator（自定义迭代器）: 使用自定义算法或迭代方法生成 Payload。
Character substitution（字符替换）: 对字符进行替换或修改来生成不同形式的 Payload。
Case modification（大小写修改）: 改变字符的大小写来生成不同形式的 Payload。
Recursive grep（递归查找）: 使用递归方式搜索目标系统，生成特定形式的 Payload。
Illegal Unicode（非法 Unicode）: 使用不合法或特殊的 Unicode 字符串生成 Payload。
Character blocks（字符块）: 将字符分组或分块，以块为单位生成 Payload。
Numbers（数字）: 针对数字型输入生成不同种类的数字 Payload。
Dates（日期）: 针对日期型输入生成不同形式的日期 Payload。
Brute forcer（暴力破解器）: 用于尝试各种可能性的暴力破解 Payload。
Null payloads（空 Payload）: 使用空值或空字符串作为 Payload。
Character frobber（字符操作）: 对字符进行多种操作生成 Payload。
Bit flipper（位操作）: 对比特位进行操作生成 Payload。
Username generator（用户名生成器）: 生成各种类型的用户名 Payload。
ECB block shuffler（ECB 块置换器）: 针对 ECB 模式加密的情况生成 Payload。
Extension-generated（扩展生成）: 由扩展或自定义脚本生成的特定 Payload。
Copy other payload（复制其他 Payload）: 复制已有 Payload 作为新的 Payload。
Collaborator payloads（协作者 Payload）: 使用 Burp Collaborator 进行协作的特定 Payload。">
<meta name="author" content="AuranLu">
<link rel="canonical" href="http://localhost:1313/posts/auran_lu/web%E6%B8%97%E9%80%8F%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%E6%89%8B%E5%86%8C/burpsuite_intruder%E7%88%86%E7%A0%B4/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.36819bea596090d8b48cf10d9831382996197aa7e4fc86f792f7c08c9ca4d23b.css" integrity="sha256-NoGb6llgkNi0jPENmDE4KZYZeqfk/Ib3kvfAjJyk0js=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/auran_lu/web%E6%B8%97%E9%80%8F%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%E6%89%8B%E5%86%8C/burpsuite_intruder%E7%88%86%E7%A0%B4/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="My New Hugo Site (Alt + H)">My New Hugo Site</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      burpsuite_intruder爆破
    </h1>
    <div class="post-meta"><span title='2025-03-10 00:00:00 +0000 UTC'>March 10, 2025</span>&nbsp;·&nbsp;AuranLu

</div>
  </header> 
  <div class="post-content"><p>Burp Intruder主要有四个模块组成:</p>
<p>1：Target 用于配置目标服务器进行攻击的详细信息。
2：Positions  设置Payloads的插入点以及攻击类型（攻击模式）。
3：Payloads  设置payload，配置字典
4：Opetions   此选项卡包含了request headers，request engine，attack results ，grep match，grep_extrack，grep payloads和redirections。你可以发动攻击之前，在主要Intruder的UI上编辑这些选项，大部分设置也可以在攻击时对已在运行的窗口进行修改。</p>
<br/>
<h2 id="attack-type攻击模式设置">attack type:攻击模式设置<a hidden class="anchor" aria-hidden="true" href="#attack-type攻击模式设置">#</a></h2>
<p><img alt="截图" loading="lazy" src="https://raw.githubusercontent.com/Auran-Lu/Blog_img/main/a3b62e0f82fa21de7260814e313dd7de.png"></p>
<ul>
<li>sniper:对变量依次进行破解。多个标记依次进行。
<ul>
<li>只能有一个payload</li>
<li>这种攻击类型是指逐个处理 Payload 列表中的每个 Payload。</li>
<li>每个 Payload 都会单独被插入到标记的位置，逐个测试，适用于针对单个位置进行深入测试的场景。</li>
<li>如果设置了三个变量A、B、C，设置了九个payload，那么先将payload插入到A变量中，当A变量测试完毕，将payload插入到B变量中，最后将payload插入到C变量进行测试.</li>
</ul>
</li>
</ul>
<br/>
<ul>
<li>
<p>battering ram:对变量同时进行破解。多个标记同时进行。</p>
<ul>
<li>只能有一个payload</li>
<li>它是Sniper的升级版，和sniper相比，battering Ram更有效率，他的原理是，同时在多个变量中进行插入测试。</li>
</ul>
<br/>
</li>
<li>
<p>pitchfork:每一个变量标记对应一个字典，取每个字典的对应项。</p>
<ul>
<li>允许设置多个payload。</li>
<li>攻击类型是指同时处理两个位置，每个位置有各自的 Payload 列表。</li>
<li>它会按照不同的组合，将第一个 Payload 和第二个 Payload 一一配对，也就是说，他会同时去测试第一个payload和第二个payload的组合。（如果两个 Payload 列表的长度不一致，Pitchfork 模式会以数量较少的那个列表为基准，按照少的列表项数进行配对测试）</li>
<li>这种攻击方式可用于测试需要两个或多个位置同时受到影响的场景。</li>
</ul>
</li>
<li>
<p>cluster bomb:每个变量对应一个字典，并且进行交集破解，尝试各种组合适用于用户名+密码的破解</p>
<ul>
<li>允许设置多个payload。</li>
<li>它更像是Pitchfork的加强版，它的功能与Pitchfork一样，可以同时测试多个payload，不同的是它的测试方式，是使用笛卡尔积，例如设置两个变量A、B，和两个payload位置，payload会交叉测试，也就是说payload1首先会是在变量A的位置，去测变量B中的payload2中所有的参数 ，当变量B中的payload2所有参数都测试完，变量A、B的payload会互相交换位置，进行测试，用最通俗的话来讲，他们就是乘法关系，假如连个payload中的参数是4个，那么他就会测试4*4=16次。</li>
<li>Cluster Bomb 通过组合 Payload 列表，生成了更多的组合，这样可以更全面、更彻底地测试目标应用程序，寻找潜在的漏洞。</li>
</ul>
</li>
</ul>
<br/>
<h3 id="payload-type">payload type<a hidden class="anchor" aria-hidden="true" href="#payload-type">#</a></h3>
<p>Simple list（简单列表）: 基本的常规 Payload 列表，可能包含用户名、密码或常见字符串。
Runtime file（运行时文件）: 在运行时生成或读取文件作为 Payload，用于测试文件上传或处理漏洞。
Custom iterator（自定义迭代器）: 使用自定义算法或迭代方法生成 Payload。
Character substitution（字符替换）: 对字符进行替换或修改来生成不同形式的 Payload。
Case modification（大小写修改）: 改变字符的大小写来生成不同形式的 Payload。
Recursive grep（递归查找）: 使用递归方式搜索目标系统，生成特定形式的 Payload。
Illegal Unicode（非法 Unicode）: 使用不合法或特殊的 Unicode 字符串生成 Payload。
Character blocks（字符块）: 将字符分组或分块，以块为单位生成 Payload。
Numbers（数字）: 针对数字型输入生成不同种类的数字 Payload。
Dates（日期）: 针对日期型输入生成不同形式的日期 Payload。
Brute forcer（暴力破解器）: 用于尝试各种可能性的暴力破解 Payload。
Null payloads（空 Payload）: 使用空值或空字符串作为 Payload。
Character frobber（字符操作）: 对字符进行多种操作生成 Payload。
Bit flipper（位操作）: 对比特位进行操作生成 Payload。
Username generator（用户名生成器）: 生成各种类型的用户名 Payload。
ECB block shuffler（ECB 块置换器）: 针对 ECB 模式加密的情况生成 Payload。
Extension-generated（扩展生成）: 由扩展或自定义脚本生成的特定 Payload。
Copy other payload（复制其他 Payload）: 复制已有 Payload 作为新的 Payload。
Collaborator payloads（协作者 Payload）: 使用 Burp Collaborator 进行协作的特定 Payload。</p>
<br/>
<h3 id="payload-settingspayload-设置">Payload Settings（Payload 设置）：<a hidden class="anchor" aria-hidden="true" href="#payload-settingspayload-设置">#</a></h3>
<p>这涉及对 Payload 进行特定配置的选项或设置。这些设置可能包括 Payload 的类型（例如字典、数字、特殊字符）、长度、频率等参数。Payload Settings 允许用户根据需要自定义和调整 Payload 的属性。</p>
<br/>
<h3 id="payload-processingpayload-处理">Payload Processing（Payload 处理）：<a hidden class="anchor" aria-hidden="true" href="#payload-processingpayload-处理">#</a></h3>
<p>这指对 Payload 进行处理、编辑或转换的过程。这可能包括对 Payload 进行编码、加密、压缩或其他形式的修改，以适应目标系统的特定要求或规范。</p>
<br/>
<h3 id="payload-encodingpayload-编码">Payload Encoding（Payload 编码）：<a hidden class="anchor" aria-hidden="true" href="#payload-encodingpayload-编码">#</a></h3>
<p>这涉及将 Payload 转换成特定格式或编码的过程。这种编码可以用于绕过输入过滤或实现特定攻击类型（例如 XSS 或 SQL 注入）。Payload Encoding 可以将 Payload 转换成 URL 编码、Base64 编码等形式，以确保在网络传输或系统处理中不会被错误解释。</p>
<br/>
<h3 id="grep---match">Grep - match:<a hidden class="anchor" aria-hidden="true" href="#grep---match">#</a></h3>
<p>定义匹配规则以筛选攻击响应中的特定文本。这可以用于标识成功的攻击或者查找感兴趣的信息。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/burpsuite_intruder%E7%88%86%E7%A0%B4/">Burpsuite_intruder爆破</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">My New Hugo Site</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
